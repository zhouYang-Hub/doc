### 理解并发、线程与等待通知机制

#### 一、进程

​	例如：一个应用程序就是一个进程，也就是一个app，由指令和数据组成；当我们不运行一个应用程序时，这些应用程序就是存放在磁盘上的二进制代码。当启动应用程序时，就把指令加载到cpu，数据加载到内存中；进程就是用来加载指令、管理内存、管理IO。

​	当一个应用程序启动被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程。

​	**进程是程序运行资源分配（以内存为主）的最小单位。**

#### 二、线程

​	线程必须依赖于进程而存在，线程是进程中的一个实体，是CPU调度的最小单位。是比进程更小，能独立运行的单位。它可以与同属于一个进程的其他线程共享该进程所拥有的全部资源。一个进程可以拥有多个线程，一个线程只能存在于一个进程。

​	**线程是CPU调度的最小单位。**

#### 三、进程与线程的区别

​	1：进程基本上是相互独立的，而线程存在于进程内，是进程的一个子集。

​	2：进程拥有的共享资源，如：内存空间等，供其内部的线程共享。

​	3：进程的通信方式更为复杂。例如：网络协议等。

​	4：线程通信相当于简单些，它们共享进程的内存，多个线程可以访问同一个共享变量。

​	5：线程更轻量，线程上下文的切换成本要比进程上下文切换低。

#### 四、CPU核心数和线程数的关系

​	一个核心CPU 只能运行一个线程。也就是说CPU的内核和同时运行的线程数是1:1 的关系；

​	使核心数与线程数形成1:2的关系。在我们前面的Windows任务管理器贴图就能看出来，内核数是6而逻辑处理器数是12。在Java中提供了Runtime.getRuntime().availableProcessors()，可以让我们获取当前的CPU核心数，注意这个核心数指的是逻辑处理器数。

#### 五、上下文切换

#### 六：并行和并发

​	并行：同时多个进行的一个操作。

​	并发：单位时间内的数量。

#### 七、线程的创建和启动

###### 	方式1：使用Thread类或者继承Thread

```java
// 创建线程 线程名字 T1
        new Thread("T1") {

            //run 方法内实现了要执行的任务
            @Override
            public void run() {
                System.out.println("Hello Thread");
                System.out.println("Thread name: " + Thread.currentThread().getName());
            }
        }.start();
```

###### 	方式2：实现Runnable接口配合Thread

```java
//使用Runnable接口配合 Thread类创建线程
        //创建任务对象
        Runnable task2 = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello Thread");
                System.out.println("Thread name: " + Thread.currentThread().getName());
            }
        };

        //task2 是任务对象；T2是线程名字
        Thread thread = new Thread(task2,"T2");
        thread.start();

//Java8 lambda 精简版本
	   Runnable task2 = () -> {
            System.out.println("Hello Thread");
        };
        Thread thread = new Thread(task2,"T2");
        thread.start();
```

​	总结：

​	Thread 才是Java里对线程唯一的抽象,Runnable 只是对任务(业务逻辑)的抽象;Thread可以接受任意一个Runnable的实例并执行。

​	方式1： 把线程和任务合并在一起；方式2：把线程和任务单独拆分开。

​	用Runnable 让人物脱离Thread继承主体，更加灵活，更容易与线程池等高级API配合使用。

###### 	方式3：FutureTask 配合Thread

```java
//FutureTask 配合Thread
        //FutureTask 能够接收Callable类型的参数，用来处理有返回结果的情况
        FutureTask<Integer> task3 = new FutureTask<>(() -> {
            System.out.println("futureTask start");
            return 20;
        });
        //参数1 是任务对象;参数 是线程名字
        new Thread(task3, "T3").start();
        //主线程阻塞，同步等待task3执行完毕的结果
        Integer rest = task3.get();
        System.out.println("futureTask rest结果: " + rest);
```

​	FutureTask 实现了RunnableFuture接口； RunnableFuture继承了Runnable、Future接口；所以 FutureTask  既可以作为Runnable被线程执行，又可以作为Future 获取到Callable的返回值。

###### 创建线程的几种方式：

​	都是new Thread类，调用start()方法启动线程：

​	1：派生自Thread类；

​	2：实现Runnable接口；

​	至于基于Callable接口，最终实现要把Callable接口的对象通过FutureTask包装成Runnable ；再交由Thread去执行，所以这个和Runnable接口看成同一类。

###### run 和start 的区别

​	通过new Thread类，只是创建了一个线程的实例，只有执行了start()才算是真正的启动线程；start()方法只是让一个线程进入就绪队列等待分配CPU，分配到CPU后才调用实现的run();

​	start()方法不能重复调用，重复调用会抛出异常.会抛出 `IllegalThreadStateException`。因为启动一次后该线程的状态已经发生变化。

###### 线程的生命周期

​	1：初始化（NEW）：创建了一个新的线程对象，但是还没调用start()方法。

​	2：运行(RUNNABLE) ：Java线程中将就绪(ready)和运行中 (running) ，统称为 运行 。线程创建后，比如：main线程调用了start()；该状态的线程处理可运行的线程池中，等待被调度线程选中，获取CPU的使用权，此时就处于就绪状态；就绪状态的线程再获得CPU时间片后变为运行中状态。

​	3：阻塞(BLOCKED)：表示线程阻塞于锁。

​	4：等待(WATING)：进入该种状态的线程需要等待其他线程做出一些特定的动作(通知或中断)。

​	5：超时等待(TIMED_WAITING)：该状态不同于WAITING；它可以再指定的时间后自行返回。

​	6：终止(TERMINATED)：表示该线程已经执行完毕。

###### 线程常见的一些方法

| 方法名           | static | 功能说明                                | 备注                                                         |
| ---------------- | ------ | --------------------------------------- | :----------------------------------------------------------- |
| start()          | N      | 启动一个新线程，在新的线程运行run方法中 | start()方法只是让线程进入就绪，但是不一定立刻运行，每个线程对象的start()只能调用一次；多次调用会报异常：IllegalThreadStateException。 |
| run()            | N      | 新线程启动后会调用的任务对象            | 如果在构造Thread 线程对象传递了Runnable参数，则线程启动后调用Runnable 的run()。 |
| join()           | N      | 等待线程运行结束                        |                                                              |
| join(long  l)    | N      | 等待线程运行结束，最多等待n 毫秒        |                                                              |
| getId()          | N      | 获取线程唯一长整型的ID                  | Id 唯一                                                      |
| getName()        | N      | 获取线程名称                            |                                                              |
| setName(String ) | N      | 修改线程名称                            |                                                              |
| getPriority()    | N      | 获取线程优先级                          |                                                              |
| setPriority(int) | N      | 修改线程的优先级                        | Java中规定线程优先级是1-10的整数，比较大的优先级能提高该线程被CPU调度的几率。 |
| getState()       | N      | 获取线程状态                            | NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED   |
| isInterrupted()  | N      | 判断是否被中断                          | 不会清除 中断标记                                            |
|                  |        |                                         |                                                              |
|                  |        |                                         |                                                              |
|                  |        |                                         |                                                              |







